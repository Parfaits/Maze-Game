package model;

import java.util.Random;

/**
 * This class gets and sets the position of the cat.
 * It also allows random cat movement upon random number input generated by random number generator.
 * It also checks to see if the cat position == player position.
 */

class Cat {
    private int xPos;
    private int yPos;

    Cat(int xPos, int yPos) {
        this.xPos = xPos;
        this.yPos = yPos;
    }

    private int getXPos() {
        return xPos;
    }

    private int getYPos() {
        return yPos;
    }

    // gets position of the cat in [x, y] form
    int[] getCatPosition(){
        return new int[]{getXPos(), getYPos()};
    }

    // generates random numbers from 0-3 to satisfy one of the four conditions in cat movement
    private int generateRandomNum(){
        Random rand = new Random();
        int upperBound = 3;
        return rand.nextInt(upperBound);
    }

    // saves position of cat's x and y coordinates upon calling random - use setPosition() to reset position.
    // FIXME: 2020-02-14 Cat often backtracks. Make so cat can backtracks only when dead end or within 3 moves.
    void move(MazeElement[][] board, Player player){
        if (board[yPos][xPos] == MazeElement.PLAYER) {
            player.setDead();
            return;
        }
        int randNum = generateRandomNum();
        switch (randNum) {
            case 0:
                if (board[yPos-1][xPos] != MazeElement.WALL){
                    if (board[yPos-1][xPos] == MazeElement.PLAYER){
                        player.setDead();
                    }
                    board[yPos-1][xPos] = MazeElement.CAT;
                    board[yPos][xPos] = MazeElement.PASSAGE;
                    yPos--;
                }
                break;

            case 1:
                if (board[yPos+1][xPos] != MazeElement.WALL){
                    if (board[yPos+1][xPos] == MazeElement.PLAYER){
                        player.setDead();
                    }
                    board[yPos+1][xPos] = MazeElement.CAT;
                    board[yPos][xPos] = MazeElement.PASSAGE;
                    yPos++;
                }
                break;

            case 2:
                if (board[yPos][xPos-1] != MazeElement.WALL){
                    if (board[yPos][xPos-1] == MazeElement.PLAYER){
                        player.setDead();
                    }
                    board[yPos][xPos-1] = MazeElement.CAT;
                    board[yPos][xPos] = MazeElement.PASSAGE;
                    xPos--;
                }
                break;

            case 3:
                if (board[yPos][xPos+1] != MazeElement.WALL){
                    if (board[yPos][xPos+1] == MazeElement.PLAYER){
                        player.setDead();
                    }
                    board[yPos][xPos+1] = MazeElement.CAT;
                    board[yPos][xPos] = MazeElement.PASSAGE;
                    xPos++;
                }
                break;

            default:
                break;
        }
    }

    private boolean isValidMove(MazeElement[][] board) {
        int randNum = generateRandomNum();
        switch (randNum) {
            case 0:
                if (board[yPos - 1][xPos] != MazeElement.WALL) {
                    System.out.println("bro why");
                    return true;
                }
                break;

            case 1:
                if (board[yPos + 1][xPos] != MazeElement.WALL) {
                    return true;
                }
                break;

            case 2:
                if (board[yPos][xPos - 1] != MazeElement.WALL) {
                    return true;

                }
                break;

            case 3:
                if (board[yPos][xPos + 1] != MazeElement.WALL) {
                    return true;
                }
                break;

            default:
                return false;
        }

        return false;
    }
}
